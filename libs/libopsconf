#!/bin/bash

OPSCONFVERSION=0.1
#GITROOTPATH="$(git rev-parse --show-toplevel)"

_prepend_v2version() {
    # We expect the version to be either a number (like 9) or a v-number (like v9)
    version=$1
    number_regexp='^[0-9]+$'
    if [[ $version =~ $number_regexp ]]; then
        version=v$version
    fi
    echo $version
}

is_git_repo() {
    git rev-parse --is-inside-work-tree >/dev/null 2>&1 
}

has_uptodate_hooks() {
    HOOKDIR="$(git rev-parse --git-dir)/hooks"
    for f in $(ls $HOOKDIR) ; do
        hookversion="$(grep OPSCONFVERSION $HOOKDIR/$f | cut -d'=' -f2)"

        if [[ $hookversion != "" && s$hookversion != $OPSCONFVERSION ]]; then
            # One issue is enough to say if it has to be updated or not
            return 1
        fi
    done
    # If we reach here, everything is fine
    return 0
}

prepend_file_version() {
    # Prepend to the commit message the version of the file ('v<VERSION>: ')
    # The version is calculated as "previous version +1", so it only works
    # because history is linear and without merges.
    # The commit file is replaced by the new commit
    #
    # @param $1: the name of the file that contains the commit message
    # @return nothing
    
    commit_msg=$(cat $1)
    filetoadd=$(git diff --cached --name-only)
    if [[ $(head -n1 $1) = "" ]]; then
        echo "[ERROR] Empty commit. Aborting"
        exit 1
    fi
    previouscommitsubject=$(git log -n 1 --pretty=format:%s $filetoadd)

    previouscommitversion_withv=$(echo $previouscommitsubject | cut -d: -f1)
    previouscommitversion_nov=${previouscommitversion_withv/v/}

    number_regexp='^[0-9]+$'
    if ! [[ $previouscommitversion_nov =~ $number_regexp ]]; then
        previouscommitversion_nov=0
    fi 

    commitversion="v$((previouscommitversion_nov+1))"
    cat <<EOF > $1
$commitversion: $commit_msg
EOF
}

forbid_several_files_commit() {
    # Control that a commit only changes one file at a time.

    if git rev-parse --verify HEAD >/dev/null 2>&1
    then
        against=HEAD
    else
        # Initial commit: diff against an empty tree object
        against=$(git hash-object -t tree /dev/null)
    fi

    changedfilecommand="git diff --cached --name-only $against"
    filenb=$($changedfilecommand | wc -l)

    if [ $filenb -eq 0 ]; then
        echo "[ERROR] Nothing to commit. Aborting."
        exit 1
    elif [ $filenb -ne 1 ]; then
        echo "[ERROR] You are commiting more than one file. Aborting."
        git reset HEAD $($changedfilecommand)
        exit 1
    fi
}

retrieve_version() {
    # Bring a file version and its associated history from one branch to
    # the current one.
    #
    # @param $1: the branch where to retrieve the change
    # @param $2: the file path to retrieve
    # @param $3: the version to retrieve (can be "latest")
    if [ "$#" -ne 3 ]; then
         echo "[ERROR] This function expects 3 arguments"
         return 1
    fi

    branch=$1
    file=$2
    version=$3

    # get the last commit on the file, on our branch
    current_hash=$(git log --format=%H -n1 HEAD -- file)
    current_hash_subject=$(git log --format=%s -n1 HEAD -- $file)
    current_hash_other=$(git log --format=%H --grep "$current_hash_subject" $branch -- $file)
    # if we don't get one, let's pretend it's HEAD,
    # it means the file does not exist yet in this branch
    if [[ $current_hash = "" ]]; then
        current_hash=$(git log --format=%H -n1 HEAD)
        current_hash_other=$(git log --diff-filter=A --format=%H -n1 $branch -- file)
    fi

    if [[ $version = "latest" ]]; then
        version_rev="$branch"
    else
        version=$(_prepend_v2version $version)
    
        version_rev=$(git log --oneline ..$branch -- $file | grep -P "^[a-z0-9]{7} $version: " | cut -d' ' -f1) 
    fi
    revs_to_retrieve=$(git log --oneline --reverse $current_hash_other..$version_rev -- $file | cut -d' ' -f1)
    git cherry-pick $revs_to_retrieve >/dev/null
    cat <<EOF >&1
[INFO] Retrieved changes of $file: 
$(git log --format=%s --reverse $current_hash..HEAD -- $file | sed -e "s/^/    /")
EOF
}

clean_local_changes() {
    file=$1
    git checkout -- $file
}

rollback_to_version() {
    file=$1
    version=$(_prepend_v2version $2)
    reason=$3
    version_hash=$(git log --grep "$version: " --format=%H -- $file)
    git diff HEAD..$version_hash -- $file | git apply
    if [ "$?" -ne 0 ]; then
        echo "[ERROR] Rollback failed. Aborting."
        git reset HEAD -- $file
        return 1
    fi
    git commit $file -m "$reason\n\nRolled-back to $version"
}

get_available_version() {
    branch=$1
    file=$2
    echo $(git log --format=%s -n1 $branch -- $file)
}

get_current_version() {
    file=$1
    branch="HEAD"
    get_available_version $branch $file
}

list_available_versions() {
    branch=$1
    file=$2
    cat <<EOF >&1
$(git log --format=%s $branch -- $file)
EOF
}

list_current_versions() {
    file=$1
    branch="HEAD"
    list_available_versions $branch $file
}

diff_between_versions() {
    file=$1
    v1=$(_prepend_v2version $2)
    v2=$(_prepend_v2version $3)

    h1=$(git log --grep "$v1: " --format=%H -- $file)
    h2=$(git log --grep "$v2: " --format=%H -- $file)
    git diff $h1..$h2 -- $file
}
