#!/bin/bash

OPSCONFVERSION=0.1

OPSCONF_BRANCH_WORK=work
OPSCONF_BRANCH_QUALIF=qualification
OPSCONF_BRANCH_VALID=master

OPSCONF_PREFIX_PATTERN="^v[0-9]\+: "
OPSCONF_PREFIX_REMOVED="vZZ: "
OPSCONF_HOOKDIR=$OPSCONF_DIR/githooks

. "$(dirname "${BASH_SOURCE[0]}")/libgit"

log_debug() {
    if [ ! -z "${OPSCONF_DEBUG+x}" ] ; then
        echo "[DEBUG] $*"
    fi
}

log_info() {
    echo "[INFO] $*"
}

log_error() {
    >&2 echo "[ERROR] $*"
}

_prepend_v2version() {
    # We expect the version to be either a number (like 9) or a v-number (like v9)
    version=$1
    number_regexp='^[0-9]+$'
    if [[ $version =~ $number_regexp ]]; then
        version=v$version
    fi
    echo "$version"
}

init_branches() {
    if git_exist_branch "$OPSCONF_BRANCH_WORK" || git_exist_branch "$OPSCONF_BRANCH_QUALIF" || git_exist_branch "$OPSCONF_BRANCH_VALID" ; then
        log_error "One of the following branch exists, aborting: $OPSCONF_BRANCH_WORK, $OPSCONF_BRANCH_QUALIF, $OPSCONF_BRANCH_VALID"
        return 1
    fi
    if [ -f "$(git_get_root)/.opsconf" ] ; then
         log_error ".opsconf file already exists. Aborting."
         return 1
    fi

    if [ "$#" -eq 1 ] ; then
        ROOT_BRANCH="$1"
        git_checkout "$ROOT_BRANCH"
        git_create_branch_orphan "$OPSCONF_BRANCH_WORK"
        find -type f | grep -v ^./.git | xargs -I@ sh -c "git add @ && git commit @ -m \"v1: First version for '@'\" &> /dev/null"
    else
        git_create_branch "$OPSCONF_BRANCH_WORK"
        touch "$(git_get_root)/README.md"
        cat > "$(git_get_root)/README.md" << EOF
# Readme
This repository is managed by opsconf.
EOF
        git_add_one_file README.md
        log_debug "Created first README"
    fi

    touch "$(git_get_root)/.opsconf"
    log_debug "Created .opsconf file"
    git_add_one_file .opsconf
    git_commit_one_file ".opsconf" "Initialized opsconf"
    commit_hash="$(git_log_last_one_file "." "HEAD" "%H")"
    git_push_new "$OPSCONF_BRANCH_WORK"
    log_debug "Opsconf committed"
    for branch in "$OPSCONF_BRANCH_VALID" "$OPSCONF_BRANCH_QUALIF" ; do
        # si la branche existe
        if git_exist_branch "$branch" ; then
            log_debug "Changing to branch: $branch"
            git_checkout "$branch"
            git_cherry_pick "$commit_hash"
            git_push "$branch"
            log_debug "Branch updated: $branch"
        else
            log_debug "Creating branch: $branch"
            git_create_branch_orphan $branch
            git_reset_hard
            git_cherry_pick "$commit_hash"
            git_push_new "$branch"
            log_debug "Branch created: $branch"
        fi
    done
    git_checkout "$OPSCONF_BRANCH_WORK"
}

is_git_repo() {
    git rev-parse --is-inside-work-tree &> /dev/null
}

is_current_branch_work() {
    current_branch=$(git_current_branch)
    if [ "$current_branch" = "$OPSCONF_BRANCH_WORK" ] ; then
        return 0
    else
        return 1
    fi
}

is_current_branch_qualif() {
    current_branch=$(git_current_branch)
    if [ "$current_branch" = "$OPSCONF_BRANCH_QUALIF" ] ; then
        return 0
    else
        return 1
    fi
}

is_current_branch_valid() {
    current_branch=$(git_current_branch)
    if [ "$current_branch" = "$OPSCONF_BRANCH_VALID" ] ; then
        return 0
    else
        return 1
    fi
}

is_repo_empty() {
    if git_is_git ; then
        return 1
    else
        return 0
    fi
}

is_opsconf_repo() {
    if git_exist_branch "$OPSCONF_BRANCH_WORK" && git_exist_branch "$OPSCONF_BRANCH_QUALIF" && git_exist_branch "$OPSCONF_BRANCH_VALID" ; then
        filenb=$(git ls-files "$OPSCONF_BRANCH_WORK" -- .opsconf | wc -l)
        if [ "$filenb" -eq 0 ] ; then
            return 1
        else
            return 0
        fi
    else
        return 1
    fi
}

has_uptodate_hooks() {
    HOOKDIR="$(git_get_gitdir)/hooks"
    for hook_src in "$OPSCONF_HOOKDIR"/* ; do
        deployed_hook="$HOOKDIR/$(basename "$hook_src")"
        # If one hook from the share dir is not in the hooks
        if [ ! -f "$deployed_hook" ]; then
            return 1
        fi
        # If it is there but with wrong version
        hookversion=$(grep OPSCONFVERSION "$deployed_hook" | cut -d'=' -f2)

        if [[ "$hookversion" != "" && "$hookversion" != "$OPSCONFVERSION" ]]; then
            # One issue is enough to say if it has to be updated or not
            return 1
        fi
    done
    # If we reach here, everything is fine
    return 0
}

get_deletion_hash() {
    file=$1
    rev=$2
    git_log_last_one_file_grep "$file" "$rev" "^$OPSCONF_PREFIX_REMOVED" "%H"
}

get_revision_range() {
    file=$1
    rev=$2

    deletion_hash=$(get_deletion_hash "$file" "$rev")
    if [ "$deletion_hash" = "" ]; then
        revision_range="$rev"
    else
        revision_range="${deletion_hash}..$rev"
    fi
    echo "$revision_range"
}

prepend_file_version() {
    # Prepend to the commit message the version of the file ('v<VERSION>: ')
    # The version is calculated as "previous version +1", so it only works
    # because history is linear and without merges.
    # The commit file is replaced by the new commit
    #
    # @param $1: the name of the file that contains the commit message
    # @return nothing

    commit_msg=$(cat "$1")
    filetoadd=$(git diff --cached --name-only)
    if [[ "$(head -n1 "$1")" = "" ]]; then
        log_error "Empty commit. Aborting"
        return 1
    fi

    if [ ! -z "${OPSCONF_BYPASS_CHECK+x}" ] ; then
        log_debug "By-passing checks and hooks"
        cat <<EOF >$1
$commit_msg
EOF
    return 0
    fi

    revision_range=$(get_revision_range "$filetoadd" "HEAD")
    previouscommitsubject=$(git_log_last_one_file "$filetoadd" "$revision_range" "%s")

    previouscommitversion_withv=$(echo "$previouscommitsubject" | cut -d: -f1)
    previouscommitversion_nov=${previouscommitversion_withv/v/}

    number_regexp='^[0-9]+$'
    if ! [[ $previouscommitversion_nov =~ $number_regexp ]]; then
        previouscommitversion_nov=0
    fi

    commitversion="v$((previouscommitversion_nov+1))"
    cat <<EOF > $1
$commitversion: $commit_msg
EOF
}

## CHECKS FOR HOOKS
check_branch_work() {
    if [ ! -z "${OPSCONF_BYPASS_CHECK+x}" ] ; then
        return 0
    fi
    if is_current_branch_work ; then
        return 0
    else
        log_error "You cannot commit on this branch. Change to $OPSCONF_BRANCH_WORK"
        return 1
    fi
}

check_branch_uptodate() {
    git fetch > /dev/null
    UPSTREAM=${1:-'@{u}'}
    LOCAL=$(git rev-parse @)
    REMOTE=$(git rev-parse "$UPSTREAM")
    if [ "$LOCAL" = "$REMOTE" ] ; then
        log_debug "Repository is up-to-date"
        return 0
    else
        log_error "The repository is not in sync. Aborting. Run 'opsconf sync'"
        git reset HEAD
        return 1
    fi
}

check_commit_unique_file() {
    # Control that a commit only changes one file at a time.

    if git rev-parse --verify HEAD >/dev/null 2>&1
    then
        against=HEAD
    else
        # Initial commit: diff against an empty tree object
        against=$(git hash-object -t tree /dev/null)
    fi

    changedfilecommand="git diff --cached --name-only $against"
    filenb=$($changedfilecommand | wc -l)

    log_debug "Number of files to commit: $filenb"
    if [ "$filenb" -eq 0 ]; then
        log_error "Nothing to commit. Aborting."
        return 1
    elif [ "$filenb" -ne 1 ]; then
        log_error "You are commiting more than one file. Aborting."
        git reset HEAD "$($changedfilecommand)"
        return 1
    else
        return 0
    fi
}

do_push() {
    branch=$(git_current_branch)
    git_push "$branch"
}

retrieve_version() {
    # Bring a file version and its associated history from one branch to
    # the current one.
    #
    # @param $1: the branch where to retrieve the change
    # @param $2: the file path to retrieve
    # @param $3: the version to retrieve
    if [ "$#" -ne 3 ]; then
         log_error "This function expects 3 arguments"
         return 1
    fi

    src_branch=$1
    file=$2
    version=$(_prepend_v2version "$3")

    revision_range=$(get_revision_range "$file" "HEAD")
    src_branch_revision_range=$(get_revision_range "$file" "$src_branch")

    if git_log_last_one_file_grep "$file" "$revision_range" "$OPSCONF_PREFIX_PATTERN" "%s" | grep "^$version" ; then
        log_info "$file is already in version $version. Nothing to do."
        return 0
    elif git_log_one_file_grep "$file" "$revision_range" "$OPSCONF_PREFIX_PATTERN" "%s" | grep "^$version" ; then
        log_error "$file is already in a latter version than $version. Aborting."
        return 1
    fi

    # get the last commit on the file, on our branch
    current_hash=$(git_log_last_one_file_grep "$file" "$revision_range" "$OPSCONF_PREFIX_PATTERN" "%H")

    # if we don't get one, let's pretend it's HEAD,
    # it means the file does not exist yet in this branch
    # So we create the v1 has the first version
    if [[ $current_hash = "" ]]; then
        log_debug "The file does not exist on this branch. Will take the first version: $file"
        current_hash=$(git log --format=%H -n1 HEAD)
        first_version_hash=$(git_log_last_one_file_grep "$file" "${src_branch_revision_range}" "^v1: " "%H")
        if [ "${first_version_hash}" = "" ] ; then
            log_error "v1 of $file does not exist in branch $src_branch"
            return 1
        fi
    first_version_commit_msg="$(git show -s --format=%B "$first_version_hash")"
        first_version_user="$(git show -s --format="%an <%ae>" "$first_version_hash")"
        first_version_date="$(git show -s --format=%ci "$first_version_hash")"

        git_get_file_from_rev "$file" "$first_version_hash"
        git_add_one_file "$file"
        export OPSCONF_BYPASS_CHECK=yes
        git commit "$file" --date="${first_version_date}" --author="${first_version_user}" -m "${first_version_commit_msg}" > /dev/null
        unset OPSCONF_BYPASS_CHECK
    fi
    current_hash_subject=$(git_log_last_one_file_grep "$file" "$revision_range" "$OPSCONF_PREFIX_PATTERN" "%s")
    current_hash_other=$(git_log_last_one_file_grep "$file" "${src_branch_revision_range}" "$current_hash_subject" "%H")

    version_rev=$(git_log_last_one_file_grep "$file" "${src_branch_revision_range}" "^$version: " "%H")
    if [ "${version_rev}" = "" ] ; then
        log_error "$version of $file does not exist in branch $src_branch"
        return 1
    fi
    revs_to_retrieve=$(git_log_one_file_grep "$file" "$current_hash_other..$version_rev" "$OPSCONF_PREFIX_PATTERN" "%h" | tac | tr '\n' ' ')
    log_debug "Cherry-picking commits: $revs_to_retrieve"
    for rev in $revs_to_retrieve ; do
        git_cherry_pick "$rev"
    done
    git_push "$(git_current_branch)"
    cat <<EOF >&1
[INFO] Retrieved changes of "$file":
$(git_log_one_file "$file" "$current_hash..HEAD" "%s" -- "$file" | tac | sed -e "s/^/    /")
EOF
}

clean_local_changes() {
    file=$1
    git_get_file_from_rev "$file" "HEAD"
}

rollback_to_version() {
    file=$1
    version=$(_prepend_v2version "$2")
    reason="$3"
    branch=$(git_current_branch)
    if [ "$(git ls-tree -r --name-only "$branch" -- "$file" )" != "$file" ] ; then
        log_error "This is not a file, or is not available in the branch $branch: $file"
        return 1
    fi
    revision_range=$(get_revision_range "$file" "HEAD")
    version_hash=$(git_log_one_file_grep "$file" "$revision_range" "^$version: " "%H")
    if ! git diff HEAD.."$version_hash" -- "$file" | git apply ; then
        log_error "Rollback failed. Aborting."
        git_get_file_from_rev "$file" "HEAD"
        return 1
    fi
    git_commit_one_file "$file" "$reason

Rolled-back to $version"
}

list_available_versions() {
    branch=$1
    file=$2

    if [ "$(git ls-tree -r --name-only "$branch" -- "$file" )" != "$file" ] ; then
        log_error "This is not a file, or is not available in the branch $branch: $file"
        return 1
    fi
    revision_range=$(get_revision_range "$file" "$branch")
    raw_logs=$(git_log_one_file_grep "$file" "$revision_range" "$OPSCONF_PREFIX_PATTERN" "%H,%s")

    # For this given file, get all the hashes that are current to the given tag
    hash_tags=""
    for tag in $(git_list_tags) ; do
        hash_tags="$hash_tags $(git_log_last_one_file "$file" "$tag" "%H"),$tag,\n"
    done
    raw_logs_and_tags=""
    # For all logs (hash,log), we get the hash
    while read -r raw_log ; do
        hash=$(echo "${raw_log}" | cut -d, -f1)
        raw_log_out=${raw_log}
        # For all tag (hash,tag), rewrite "hash,log" by "tag hash,log"
        # After a while you get "tag tag tag hash, log"
        while read hash_tag ; do
            tag=$(echo "${hash_tag}" | cut -d, -f2)
            raw_log_out="${raw_log_out/$hash/$tag $hash}"
        done < <(echo -e "${hash_tags}" | grep "$hash")
        # Remove the hash to get "tag tag tag , log"
        raw_logs_and_tags="$raw_logs_and_tags ${raw_log_out/$hash/}\n"
    done < <(echo -e "$raw_logs")

    raw_logs_and_tags=$(echo -e "$raw_logs_and_tags")

    if [ -n "${raw_logs_and_tags}" ] ; then
        formated_logs=$(echo "${raw_logs_and_tags}" | sed 's,^ \(.*\)\,v\([[:digit:]]\+\): \(.*\)$,\2\t\3\t\1\t,' | column -t -s $'\t' -o' | ')
        cat <<EOF >&1
${formated_logs}
EOF
    fi
}

list_all_versions() {
    file=$1
    branch="$OPSCONF_BRANCH_WORK"
    list_available_versions "$branch" "$file"
}

list_current_versions() {
    file=$1
    branch="HEAD"
    list_available_versions "$branch" "$file"
}

show_current_versions() {
    rev=$1
    line_to_show='echo -e "$1\t$(git log --format=%s -n1 "$2" -- "$1"|cut -d: -f1)"'
    raw_logs=$(git ls-tree -r --name-only "$rev" | grep -v '^.opsconf$' | xargs -I@ sh -c "$line_to_show" sh @ "$rev")
    if [ -n "${raw_logs}" ] ; then
        formated_logs=$(echo "${raw_logs}" | sort | column -t -s $'\t' -o' | ')
        cat <<EOF >&1
${formated_logs}
EOF
    fi
}

remove_file() {
    file=$1
    reason=$2
    branch=$(git_current_branch)
    if [ "$(git ls-tree -r --name-only "$branch" -- "$file" )" != "$file" ] ; then
        log_error "File not found in the branch $branch: $file"
        return 1
    fi
    git_remove_one_file "$file"
    export OPSCONF_BYPASS_CHECK=yes
    git_commit_one_file "$file" "${OPSCONF_PREFIX_REMOVED}${reason}"
    unset OPSCONF_BYPASS_CHECK
}

diff_between_versions() {
    file=$1
    v1=$(_prepend_v2version "$2")
    v2=$(_prepend_v2version "$3")

    h1=$(git_log_last_one_file_grep "$file" "HEAD" "^$v1: " "%H")
    h2=$(git_log_last_one_file_grep "$file" "HEAD" "^$v2: " "%H")
    git_diff_one_file "$file" "$h1" "$h2"
}
