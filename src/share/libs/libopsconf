#!/bin/bash

OPSCONFVERSION=0.1

OPSCONF_BRANCH_WORK=work
OPSCONF_BRANCH_QUALIF=qualification
OPSCONF_BRANCH_VALID=master

log_debug() {
    if [ ! -z "${OPSCONF_DEBUG+x}" ] ; then
        echo "[DEBUG] $*"
    fi
}

log_info() {
    echo "[INFO] $*"
}

log_error() {
    >&2 echo "[ERROR] $*"
}

_prepend_v2version() {
    # We expect the version to be either a number (like 9) or a v-number (like v9)
    version=$1
    number_regexp='^[0-9]+$'
    if [[ $version =~ $number_regexp ]]; then
        version=v$version
    fi
    echo "$version"
}

get_git_root() {
    git rev-parse --show-toplevel
}

get_current_branch() {
    git rev-parse --abbrev-ref HEAD
}

init_branches() {
    touch "$(get_git_root)/README.md"
    cat > "$(get_git_root)/README.md" << EOF
# Readme
This repository is managed by opsconf.
EOF
    log_debug "Created first README"
    touch "$(get_git_root)/.opsconf"
    log_debug "Created .opsconf file"
    git add README.md .opsconf >/dev/null
    git commit -m "First commit" &>/dev/null
    log_debug "README commited"
    for branch in "$OPSCONF_BRANCH_VALID" "$OPSCONF_BRANCH_QUALIF" "$OPSCONF_BRANCH_WORK" ; do
        # si la branche existe
        if git branch | grep $branch &>/dev/null ; then
            git checkout $branch &>/dev/null
            git push origin $branch &>/dev/null
            log_debug "Branch updated: $branch"
        else
            git checkout -b $branch &>/dev/null
            git push -u origin $branch &>/dev/null
            log_debug "Branch created: $branch"
        fi
    done
}

is_current_branch_work() {
    current_branch=$(get_current_branch)
    if [ "$current_branch" = "$OPSCONF_BRANCH_WORK" ] ; then
        return 0
    else
        return 1
    fi
}

is_current_branch_qualif() {
    current_branch=$(get_current_branch)
    if [ "$current_branch" = "$OPSCONF_BRANCH_QUALIF" ] ; then
        return 0
    else
        return 1
    fi
}

is_current_branch_valid() {
    current_branch=$(get_current_branch)
    if [ "$current_branch" = "$OPSCONF_BRANCH_VALID" ] ; then
        return 0
    else
        return 1
    fi
}

is_repo_empty() {
    git rev-parse --verify HEAD >/dev/null 2>&1
    if [ "$?" -eq "0" ] ; then 
        return 1
    else
        return 0
    fi
}

has_uptodate_hooks() {
    HOOKDIR="$(git rev-parse --git-dir)/hooks"
    for f in "$HOOKDIR"/* ; do
        hookversion=$(grep OPSCONFVERSION "$f" | cut -d'=' -f2)

        if [[ "$hookversion" != "" && "$hookversion" != "$OPSCONFVERSION" ]]; then
            # One issue is enough to say if it has to be updated or not
            return 1
        fi
    done
    # If we reach here, everything is fine
    return 0
}

prepend_file_version() {
    # Prepend to the commit message the version of the file ('v<VERSION>: ')
    # The version is calculated as "previous version +1", so it only works
    # because history is linear and without merges.
    # The commit file is replaced by the new commit
    #
    # @param $1: the name of the file that contains the commit message
    # @return nothing
    
    commit_msg=$(cat "$1")
    filetoadd=$(git diff --cached --name-only)
    if [[ "$(head -n1 "$1")" = "" ]]; then
        log_error "Empty commit. Aborting"
        return 1
    fi
    previouscommitsubject=$(git log -n 1 --pretty=format:%s "$filetoadd")

    previouscommitversion_withv=$(echo "$previouscommitsubject" | cut -d: -f1)
    previouscommitversion_nov=${previouscommitversion_withv/v/}

    number_regexp='^[0-9]+$'
    if ! [[ $previouscommitversion_nov =~ $number_regexp ]]; then
        previouscommitversion_nov=0
    fi 

    commitversion="v$((previouscommitversion_nov+1))"
    cat <<EOF > $1
$commitversion: $commit_msg
EOF
}

## CHECKS FOR HOOKS
check_branch_work() {
    if is_current_branch_work ; then
        return 0
    else
        log_error "You cannot commit on this branch. Change to $OPSCONF_BRANCH_WORK"
        return 1
    fi
}

check_branch_uptodate() {
    git fetch
    UPSTREAM=${1:-'@{u}'}
    LOCAL=$(git rev-parse @)
    REMOTE=$(git rev-parse "$UPSTREAM")
    if [ "$LOCAL" = "$REMOTE" ] ; then
        log_debug "Repository is up-to-date"
        return 0
    else
        log_error "The repository is not in sync. Aborting. Run 'opsconf sync'"
        git reset HEAD
        return 1
    fi
}

check_commit_unique_file() {
    # Control that a commit only changes one file at a time.

    if git rev-parse --verify HEAD >/dev/null 2>&1
    then
        against=HEAD
    else
        # Initial commit: diff against an empty tree object
        against=$(git hash-object -t tree /dev/null)
    fi

    changedfilecommand="git diff --cached --name-only $against"
    filenb=$($changedfilecommand | wc -l)

    log_debug "Number of files to commit: $filenb"
    if [ "$filenb" -eq 0 ]; then
        log_error "Nothing to commit. Aborting."
        return 1
    elif [ "$filenb" -ne 1 ]; then
        log_error "You are commiting more than one file. Aborting."
        git reset HEAD "$($changedfilecommand)"
        return 1
    else 
        return 0
    fi
}

do_push() {
    branch=$(get_current_branch)
    git push origin "$branch"
}

retrieve_version() {
    # Bring a file version and its associated history from one branch to
    # the current one.
    #
    # @param $1: the branch where to retrieve the change
    # @param $2: the file path to retrieve
    # @param $3: the version to retrieve (can be "latest")
    if [ "$#" -ne 3 ]; then
         log_error "This function expects 3 arguments"
         return 1
    fi

    branch=$1
    file=$2
    version=$3

    # get the last commit on the file, on our branch
    current_hash=$(git log --format=%H -n1 HEAD -- "$file")

    # if we don't get one, let's pretend it's HEAD,
    # it means the file does not exist yet in this branch
    if [[ $current_hash = "" ]]; then
        log_debug "The file does not exist on this branch: $file"
        current_hash=$(git log --format=%H -n1 HEAD)
        current_hash_other=$(git log --diff-filter=A --format=%H -n1 "$branch" -- "$file")
    else
        current_hash_subject=$(git log --format=%s -n1 HEAD -- "$file")
        current_hash_other=$(git log --format=%H --grep "$current_hash_subject" "$branch" -- "$file")
    fi

    if [[ $version = "latest" ]]; then
        version_rev="$branch"
    else
        version=$(_prepend_v2version "$version")
    
        version_rev=$(git log --oneline .."$branch" -- "$file" | grep -P "^[a-z0-9]{7} $version: " | cut -d' ' -f1) 
    fi
    revs_to_retrieve=$(git log --oneline --reverse "$current_hash_other".."$version_rev" -- "$file" | cut -d' ' -f1)
    log_debug "Cherry-picking commits: $revs_to_retrieve"
    for rev in $revs_to_retrieve ; do
        git cherry-pick "$rev" >/dev/null
    done
    cat <<EOF >&1
[INFO] Retrieved changes of "$file": 
$(git log --format=%s --reverse "$current_hash"..HEAD -- "$file" | sed -e "s/^/    /")
EOF
}

clean_local_changes() {
    file=$1
    git checkout -- "$file"
}

rollback_to_version() {
    file=$1
    version=$(_prepend_v2version "$2")
    reason="$3"
    version_hash=$(git log --grep "$version: " --format=%H -- "$file")
    if ! git diff HEAD.."$version_hash" -- "$file" | git apply ; then
        log_error "Rollback failed. Aborting."
        git reset HEAD -- "$file"
        return 1
    fi
    git commit "$file" -m "$reason

Rolled-back to $version"
}

get_available_version() {
    branch=$1
    file=$2
    git log --format=%s -n1 "$branch" -- "$file"
}

get_current_version() {
    file=$1
    branch="HEAD"
    get_available_version "$branch" "$file"
}

list_available_versions() {
    branch=$1
    file=$2
    cat <<EOF >&1
$(git log --format=%s "$branch" -- "$file")
EOF
}

list_all_versions() {
    file=$1
    branch="$OPSCONF_BRANCH_WORK"
    list_available_versions "$branch" "$file"
}

list_current_versions() {
    file=$1
    branch="HEAD"
    list_available_versions "$branch" "$file"
}

diff_between_versions() {
    file=$1
    v1=$(_prepend_v2version "$2")
    v2=$(_prepend_v2version "$3")

    h1=$(git log --grep "$v1: " --format=%H -- "$file")
    h2=$(git log --grep "$v2: " --format=%H -- "$file")
    git diff "$h1".."$h2" -- "$file"
}
