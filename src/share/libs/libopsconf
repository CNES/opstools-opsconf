#!/bin/bash

OPSCONFVERSION=0.1

OPSCONF_BRANCH_WORK=work
OPSCONF_BRANCH_QUALIF=qualification
OPSCONF_BRANCH_VALID=master

OPSCONF_PREFIX_PATTERN="^v[0-9]\+: "
OPSCONF_HOOKDIR=$OPSCONF_DIR/githooks

log_debug() {
    if [ ! -z "${OPSCONF_DEBUG+x}" ] ; then
        echo "[DEBUG] $*"
    fi
}

log_info() {
    echo "[INFO] $*"
}

log_error() {
    >&2 echo "[ERROR] $*"
}

_prepend_v2version() {
    # We expect the version to be either a number (like 9) or a v-number (like v9)
    version=$1
    number_regexp='^[0-9]+$'
    if [[ $version =~ $number_regexp ]]; then
        version=v$version
    fi
    echo "$version"
}

get_git_root() {
    git rev-parse --show-toplevel
}

get_current_branch() {
    git rev-parse --abbrev-ref HEAD
}

init_branches() {
    if git show-ref --quiet "refs/heads/$OPSCONF_BRANCH_WORK" || git show-ref --quiet "refs/heads/$OPSCONF_BRANCH_QUALIF" || git show-ref --quiet "refs/heads/$OPSCONF_BRANCH__VALID" ; then
        log_error "One of the following branch exists, aborting: $OPSCONF_BRANCH_WORK, $OPSCONF_BRANCH_QUALIF, $OPSCONF_BRANCH_VALID"
        exit 1
    fi
    if [ -f "$(get_git_root)/.opsconf" ] ; then
         log_error ".opsconf file already exists. Aborting."
         exit 1
    fi

    if [ "$#" -eq 1 ] ; then
        ROOT_BRANCH="$1"
        git checkout "$ROOT_BRANCH" &> /dev/null
        git checkout --orphan "$OPSCONF_BRANCH_WORK"
        find -type f | grep -v ^./.git | xargs -I@ sh -c "git add @ && git commit @ -m \"v1: First version for '@'\" &> /dev/null"
    else
        git checkout -b "$OPSCONF_BRANCH_WORK" > /dev/null
        touch "$(get_git_root)/README.md"
        cat > "$(get_git_root)/README.md" << EOF
# Readme
This repository is managed by opsconf.
EOF
        git add README.md > /dev/null
        log_debug "Created first README"
    fi

    touch "$(get_git_root)/.opsconf"
    log_debug "Created .opsconf file"
    git add .opsconf > /dev/null
    git commit -m "Initialized opsconf" &>/dev/null
    commit_hash="$(git log --format=%H -n1)"
    git push -u origin "$OPSCONF_BRANCH_WORK" &> /dev/null
    log_debug "Opsconf committed"
    for branch in "$OPSCONF_BRANCH_VALID" "$OPSCONF_BRANCH_QUALIF" ; do
        # si la branche existe
        if git show-ref --quiet "refs/heads/$branch" ; then
            git checkout $branch &>/dev/null
            git cherry-pick "$commit_hash" &>/dev/null
            git push origin $branch &>/dev/null
            log_debug "Branch updated: $branch"
        else
            git checkout --orphan $branch &>/dev/null
            git reset --hard
            git cherry-pick "$commit_hash" &> /dev/null
            git push -u origin $branch &>/dev/null
            log_debug "Branch created: $branch"
        fi
    done
    git checkout "$OPSCONF_BRANCH_WORK" &> /dev/null
}

is_git_repo() {
    git rev-parse --is-inside-work-tree &> /dev/null
}

is_current_branch_work() {
    current_branch=$(get_current_branch)
    if [ "$current_branch" = "$OPSCONF_BRANCH_WORK" ] ; then
        return 0
    else
        return 1
    fi
}

is_current_branch_qualif() {
    current_branch=$(get_current_branch)
    if [ "$current_branch" = "$OPSCONF_BRANCH_QUALIF" ] ; then
        return 0
    else
        return 1
    fi
}

is_current_branch_valid() {
    current_branch=$(get_current_branch)
    if [ "$current_branch" = "$OPSCONF_BRANCH_VALID" ] ; then
        return 0
    else
        return 1
    fi
}

is_repo_empty() {
    git rev-parse --verify HEAD >/dev/null 2>&1
    if [ "$?" -eq "0" ] ; then
        return 1
    else
        return 0
    fi
}

is_opsconf_repo() {
    if git show-ref --quiet "refs/heads/$OPSCONF_BRANCH_WORK" && git show-ref --quiet "refs/heads/$OPSCONF_BRANCH_QUALIF" && git show-ref --quiet "refs/heads/$OPSCONF_BRANCH_VALID" ; then
        filenb=$(git ls-files "$OPSCONF_BRANCH_WORK" -- .opsconf | wc -l)
        if [ "$filenb" -eq 0 ] ; then
            return 1
        else
            return 0
        fi
    else
        return 1
    fi
}

has_uptodate_hooks() {
    HOOKDIR="$(git rev-parse --git-dir)/hooks"
    for hook_src in "$OPSCONF_HOOKDIR"/* ; do
        deployed_hook="$HOOKDIR/$(basename "$hook_src")"
        # If one hook from the share dir is not in the hooks
        if [ ! -f "$deployed_hook" ]; then
            return 1
        fi
        # If it is there but with wrong version
        hookversion=$(grep OPSCONFVERSION "$deployed_hook" | cut -d'=' -f2)

        if [[ "$hookversion" != "" && "$hookversion" != "$OPSCONFVERSION" ]]; then
            # One issue is enough to say if it has to be updated or not
            return 1
        fi
    done
    # If we reach here, everything is fine
    return 0
}

prepend_file_version() {
    # Prepend to the commit message the version of the file ('v<VERSION>: ')
    # The version is calculated as "previous version +1", so it only works
    # because history is linear and without merges.
    # The commit file is replaced by the new commit
    #
    # @param $1: the name of the file that contains the commit message
    # @return nothing

    commit_msg=$(cat "$1")
    filetoadd=$(git diff --cached --name-only)
    if [[ "$(head -n1 "$1")" = "" ]]; then
        log_error "Empty commit. Aborting"
        return 1
    fi
    previouscommitsubject=$(git log -n 1 --pretty=format:%s "$filetoadd")

    previouscommitversion_withv=$(echo "$previouscommitsubject" | cut -d: -f1)
    previouscommitversion_nov=${previouscommitversion_withv/v/}

    number_regexp='^[0-9]+$'
    if ! [[ $previouscommitversion_nov =~ $number_regexp ]]; then
        previouscommitversion_nov=0
    fi

    commitversion="v$((previouscommitversion_nov+1))"
    cat <<EOF > $1
$commitversion: $commit_msg
EOF
}

## CHECKS FOR HOOKS
check_branch_work() {
    if [ ! -z "${OPSCONF_BYPASS_CHECK+x}" ] ; then
        return 0
    fi
    if is_current_branch_work ; then
        return 0
    else
        log_error "You cannot commit on this branch. Change to $OPSCONF_BRANCH_WORK"
        return 1
    fi
}

check_branch_uptodate() {
    git fetch > /dev/null
    UPSTREAM=${1:-'@{u}'}
    LOCAL=$(git rev-parse @)
    REMOTE=$(git rev-parse "$UPSTREAM")
    if [ "$LOCAL" = "$REMOTE" ] ; then
        log_debug "Repository is up-to-date"
        return 0
    else
        log_error "The repository is not in sync. Aborting. Run 'opsconf sync'"
        git reset HEAD
        return 1
    fi
}

check_commit_unique_file() {
    # Control that a commit only changes one file at a time.

    if git rev-parse --verify HEAD >/dev/null 2>&1
    then
        against=HEAD
    else
        # Initial commit: diff against an empty tree object
        against=$(git hash-object -t tree /dev/null)
    fi

    changedfilecommand="git diff --cached --name-only $against"
    filenb=$($changedfilecommand | wc -l)

    log_debug "Number of files to commit: $filenb"
    if [ "$filenb" -eq 0 ]; then
        log_error "Nothing to commit. Aborting."
        return 1
    elif [ "$filenb" -ne 1 ]; then
        log_error "You are commiting more than one file. Aborting."
        git reset HEAD "$($changedfilecommand)"
        return 1
    else
        return 0
    fi
}

do_push() {
    branch=$(get_current_branch)
    git push origin "$branch" &> /dev/null
}

retrieve_version() {
    # Bring a file version and its associated history from one branch to
    # the current one.
    #
    # @param $1: the branch where to retrieve the change
    # @param $2: the file path to retrieve
    # @param $3: the version to retrieve (can be "latest")
    if [ "$#" -ne 3 ]; then
         log_error "This function expects 3 arguments"
         return 1
    fi

    src_branch=$1
    file=$2
    version=$3

    # get the last commit on the file, on our branch
    current_hash=$(git log --grep "$OPSCONF_PREFIX_PATTERN" --format=%H -n1 HEAD -- "$file")

    # if we don't get one, let's pretend it's HEAD,
    # it means the file does not exist yet in this branch
    # So we create the v1 has the first version
    if [[ $current_hash = "" ]]; then
        log_debug "The file does not exist on this branch: $file"
        current_hash=$(git log --format=%H -n1 HEAD)
        first_version_hash="$(git log --grep "^v1: " --format=%H -n1 "$src_branch" -- "$file")"
        first_version_commit_msg="$(git show -s --format=%B "$first_version_hash")"
        first_version_commit_msg="${first_version_commit_msg/v1: /}"  # Remove "v1: " that will be added by the hooks
        first_version_user="$(git show -s --format="%an <%ae>" "$first_version_hash")"
        first_version_date="$(git show -s --format=%ci "$first_version_hash")"

        git checkout "$first_version_hash" -- "$file" > /dev/null
        git add "$file" > /dev/null
        export OPSCONF_BYPASS_CHECK=yes
        git commit "$file" --date="${first_version_date}" --author="${first_version_user}" -m "${first_version_commit_msg}" > /dev/null
        unset OPSCONF_BYPASS_CHECK
    fi
    current_hash_subject=$(git log --grep "$OPSCONF_PREFIX_PATTERN" --format=%s -n1 HEAD -- "$file")
    current_hash_other=$(git log --format=%H --grep "$current_hash_subject" "$src_branch" -- "$file")

    if [ "$version" = "latest" ]; then
        version_rev="$src_branch"
    else
        version=$(_prepend_v2version "$version")

        version_rev=$(git log --grep "^$version: " --format=%H .."$src_branch" -- "$file")
    fi
    if [ "${version_rev}" = "" ] ; then
        log_error "$version of $file does not exist"
        return 1
    fi
    revs_to_retrieve=$(git log --grep "$OPSCONF_PREFIX_PATTERN" --format=%h --reverse "$current_hash_other".."$version_rev" -- "$file" | tr '\n' ' ')
    log_debug "Cherry-picking commits: $revs_to_retrieve"
    for rev in $revs_to_retrieve ; do
        git cherry-pick "$rev" > /dev/null
    done
    git push origin "$(get_current_branch)" &> /dev/null
    cat <<EOF >&1
[INFO] Retrieved changes of "$file":
$(git log --format=%s --reverse "$current_hash"..HEAD -- "$file" | sed -e "s/^/    /")
EOF
}

clean_local_changes() {
    file=$1
    git checkout -- "$file"
}

rollback_to_version() {
    file=$1
    version=$(_prepend_v2version "$2")
    reason="$3"
    version_hash=$(git log --grep "^$version: " --format=%H -- "$file")
    if ! git diff HEAD.."$version_hash" -- "$file" | git apply ; then
        log_error "Rollback failed. Aborting."
        git reset HEAD -- "$file"
        return 1
    fi
    git commit "$file" -m "$reason

Rolled-back to $version"
}

get_available_version() {
    branch=$1
    file=$2
    git log --format=%s -n1 "$branch" -- "$file"
}

get_current_version() {
    file=$1
    branch="HEAD"
    get_available_version "$branch" "$file"
}

list_available_versions() {
    branch=$1
    file=$2
    raw_logs=$(git log --grep "$OPSCONF_PREFIX_PATTERN" --format=%s "$branch" -- "$file")
    if [ -n "${raw_logs}" ] ; then
        formated_logs=$(echo "${raw_logs}" | sed 's,\([[:digit:]]\+\): ,\1ยง,' | column -t -sยง -o' | ')
        cat <<EOF >&1
${formated_logs}
EOF
    fi
}

list_all_versions() {
    file=$1
    branch="$OPSCONF_BRANCH_WORK"
    list_available_versions "$branch" "$file"
}

list_current_versions() {
    file=$1
    branch="HEAD"
    list_available_versions "$branch" "$file"
}

diff_between_versions() {
    file=$1
    v1=$(_prepend_v2version "$2")
    v2=$(_prepend_v2version "$3")

    h1=$(git log --grep "^$v1: " --format=%H -- "$file")
    h2=$(git log --grep "^$v2: " --format=%H -- "$file")
    git diff "$h1".."$h2" -- "$file"
}
