#!/bin/bash -e

_show_help() {
    exitcode=$1
    cat <<EOF
opsconf commit -m MESSAGE FILE: Commits the single file FILE with the commit message MESSAGE
opsconf commit -r -m MESSAGE DIRECTORY: Recursively commits the files contained in the DIRECTORY with the commit message MESSAGE
EOF
    exit "$exitcode"
}

commit_file() {
    file="$1"
    commit_msg="$2"
    git_add_one_file "$file"
    log_debug "File added: \"$file\""
    if [ "$commit_msg" = "" ]; then
        git_commit_one_file "$file"
    else
        git_commit_one_file "$file" "$commit_msg"
    fi
    version=$(git_log_last_one_file_grep "$file" "HEAD" "$OPSCONF_PREFIX_PATTERN" "%s" | cut -d: -f1)

    log_info "File commited: \"$file\", $version"
}

run_cmd() {
    if [ $# -eq 0 ] ; then
        _show_help 1
    fi
    local recurse=1
    local commit_msg=""
    ## Traitement des arguments
    while [ $# -ne 0 ] ; do
        if [ "$1" = "-m" ] ; then
            commit_msg=$2
            log_debug "Commit message: $commit_msg"
            shift 2
        elif [ "$1" = "-r" ]; then
            recurse=0
            log_debug "Go recursive"
            shift
        else
            file=$1
            shift
        fi
    done
    
    # Le champs FILE est absolument nécessaire.
    if [ -z "$file" ] ; then
        _show_help 1
    fi
    
    # Retirer tous les fichiers ajoutés: on fait tout via "commit"
    git_reset_soft

    ## Si recursif
    if [ "$recurse" -eq 0 ]; then
        # Soit on a un dossier
        if [ -d "$file" ] ; then
            # Dans ce cas on récurse sur les fichiers modifiés de ce dossier
            subfiles=$(git diff --name-only "$file")

            for f in $subfiles ; do
                run_cmd -m "$commit_msg" "$f"
            done
        # Soit on a un fichier
        elif [ -f "$file" ] ; then
            commit_file "$file" "$commit_msg"
        fi
    # Si pas récursif, on se ramène au cas "fichier"
    else
        commit_file "$file" "$commit_msg"
    fi
}
